Automatically generated by Mendeley Desktop 1.16.3
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@inproceedings{Rosenberg2016,
  author = {Rosenberg, Carl Martin and Steffen, Martin and Stolz, Volker},
  booktitle = {Runtime Verification - 16th International Conference, Madrid},
  doi = {10.1007/978-3-319-46982-9_20},
  file = {:Users/Alex/Documents/Mendeley Desktop/Rosenberg, Steffen, Stolz/Leveraging DTrace for Runtime Verification/Rosenberg, Steffen, Stolz - 2016 - Leveraging DTrace for Runtime Verification.pdf:pdf},
  isbn = {978-3-319-46981-2},
  pages = {318--332},
  title = {{Leveraging DTrace for Runtime Verification}},
  url = {http://link.springer.com/10.1007/978-3-319-46982-9{\_}20},
  year = {2016}
}
@incollection{Tobergte2013,
  abstract = {Predicting the binding mode of flexible polypeptides to proteins is an important task that falls outside the domain of applicability of most small molecule and protein−protein docking tools. Here, we test the small molecule flexible ligand docking program Glide on a set of 19 non-$\alpha$-helical peptides and systematically improve pose prediction accuracy by enhancing Glide sampling for flexible polypeptides. In addition, scoring of the poses was improved by post-processing with physics-based implicit solvent MM- GBSA calculations. Using the best RMSD among the top 10 scoring poses as a metric, the success rate (RMSD ≤ 2.0 {\AA} for the interface backbone atoms) increased from 21{\%} with default Glide SP settings to 58{\%} with the enhanced peptide sampling and scoring protocol in the case of redocking to the native protein structure. This approaches the accuracy of the recently developed Rosetta FlexPepDock method (63{\%} success for these 19 peptides) while being over 100 times faster. Cross-docking was performed for a subset of cases where an unbound receptor structure was available, and in that case, 40{\%} of peptides were docked successfully. We analyze the results and find that the optimized polypeptide protocol is most accurate for extended peptides of limited size and number of formal charges, defining a domain of applicability for this approach.},
  archivePrefix = {arXiv},
  arxivId = {arXiv:1011.1669v3},
  author = {Havelund, Klaus and Roşu, Grigore},
  booktitle = {CEUR Workshop Proceedings},
  doi = {10.1007/3-540-46002-0_24},
  eprint = {arXiv:1011.1669v3},
  file = {:Users/Alex/Documents/Mendeley Desktop/Havelund, Roşu/Synthesizing Monitors for Safety Properties/Havelund, Roşu - 2002 - Synthesizing Monitors for Safety Properties.pdf:pdf},
  isbn = {9788578110796},
  issn = {16130073},
  keywords = {Mobile,Named entity disambiguation,Natural language processing,News,Recommender system},
  number = {9},
  pages = {342--356},
  pmid = {25246403},
  title = {{Synthesizing Monitors for Safety Properties}},
  url = {http://link.springer.com/10.1007/3-540-46002-0{\_}24},
  volume = {1542},
  year = {2002}
}
@article{Hoxha2015,
  abstract = {We propose to standardize two Matlab/Simulink models of automotive systems as benchmark prob-lems for hybrid system verification. Both models can be simulated quickly, making them ideal for testing-based verification methods that require a significant number of system output trajectories. One of the benchmarks is the Automatic Transmission model, which is deterministic. The other benchmark is the Fault-Tolerant Fuel Control System, which exhibits stochastic behavior. Our benchmark stan-dardization defines a number of Metric Temporal Logic requirements for the models.},
  author = {Hoxha, Bardh and Abbas, Houssam and Fainekos, Georgios},
  file = {:Users/Alex/Documents/Mendeley Desktop/Hoxha, Abbas, Fainekos/Benchmarks for Temporal Logic Requirements for Automotive Systems/Hoxha, Abbas, Fainekos - 2015 - Benchmarks for Temporal Logic Requirements for Automotive Systems.pdf:pdf},
  journal = {ARCH15 (EPiC Series in Computer Science, vol. 34)},
  keywords = {Category,academic Difficulty,medium},
  pages = {25--30},
  title = {{Benchmarks for Temporal Logic Requirements for Automotive Systems}},
  url = {http://www.easychair.org/publications/download/Benchmarks{\_}for{\_}Temporal{\_}Logic{\_}Requirements{\_}for{\_}Automotive{\_}Systems},
  volume = {34},
  year = {2015}
}
@article{Sen2004,
  abstract = {We describe an efficient decentralized monitoring algorithm that monitors a distributed program's execution to check for violations of safety properties. The monitoring is based on formulae written in PT-DTL, a variant of past time linear temporal logic that we define. PT-DTL is suitable for expressing temporal properties of distributed systems. Specifically, the formulae of PT-DTL are relative to a particular process and are interpreted over a projection of the trace of global states that represents what that process is aware of. A formula relative to one process may refer to other processes' local states through remote expressions and remote formulae. In order to correctly evaluate remote expressions, we introduce the notion of KNOWLEDGEVECTOR and provide an algorithm which keeps a process aware of other processes' local states that can affect the validity of a monitored PT-DTL formula. Both the logic and the monitoring algorithm are illustrated through a number of examples. Finally, we describe our implementation of the algorithm in a tool called DIANA.},
  author = {Sen, Koushik and Vardhan, Abhay and Agha, Gul and Rosu, Grigore},
  doi = {10.1109/ICSE.2004.1317464},
  file = {:Users/Alex/Documents/Mendeley Desktop/Sen et al/Efficient Decentralized Monitoring of Safety in Distributed Systems/Sen et al. - 2004 - Efficient Decentralized Monitoring of Safety in Distributed Systems.pdf:pdf},
  isbn = {0-7695-2163-0},
  issn = {02705257},
  journal = {26th International Conference on Software Engineering, ICSE 2004},
  keywords = {Monitoring},
  number = {October},
  pages = {418--427},
  title = {{Efficient Decentralized Monitoring of Safety in Distributed Systems}},
  volume = {V},
  year = {2004}
}
@article{Alur1994,
  author = {Alur, Rajeev and Dill, D.L.},
  doi = {10.1.1.51.1093},
  file = {:Users/Alex/Documents/Mendeley Desktop/Alur, Dill/A theory of timed automata/Alur, Dill - 1994 - A theory of timed automata.pdf:pdf},
  issn = {03043975},
  journal = {Theoretical computer science},
  keywords = {automatic veri cation,automaton,formal languages and au-,formal methods,real-time systems},
  number = {2},
  pages = {183--235},
  title = {{A theory of timed automata}},
  url = {http://www.sciencedirect.com/science/article/pii/0304397594900108},
  volume = {126},
  year = {1994}
}
@article{Halbwachs2005,
  abstract = { We recall the story of the development of the synchronous data-flow language Lustre and of its industrial transfer inside the toolset SCADE. We try to analyse the reasons of its success, and to report the main lessons we got from the transfer of an academic concept into real industrial world.},
  author = {Halbwachs, Nicolas},
  doi = {10.1109/MEMCOD.2005.1487884},
  file = {:Users/Alex/Documents/Mendeley Desktop/Halbwachs/A synchronous language at work The story of Lustre/Halbwachs - 2005 - A synchronous language at work The story of Lustre.pdf:pdf},
  isbn = {9780470876183},
  journal = {Proceedings - Third ACM and IEEE International Conference on Formal Methods and Models for Co-Design, MEMOCODE'05},
  pages = {3--11},
  title = {{A synchronous language at work: The story of Lustre}},
  volume = {2005},
  year = {2005}
}
@article{Yucesan1992,
  author = {Y{\"{u}}cesan, Enver and Schruben, Lee},
  doi = {10.1145/132277.132281},
  file = {:Users/Alex/Documents/Mendeley Desktop/Y{\"{u}}cesan, Schruben/Structural and behavioral equivalence of simulation models/Y{\"{u}}cesan, Schruben - 1992 - Structural and behavioral equivalence of simulation models.pdf:pdf},
  isbn = {1049-3301},
  issn = {10493301},
  journal = {ACM Transactions on Modeling and Computer Simulation},
  number = {1},
  pages = {82--103},
  title = {{Structural and behavioral equivalence of simulation models}},
  url = {http://portal.acm.org/citation.cfm?doid=132277.132281},
  volume = {2},
  year = {1992}
}
@article{Scheffel2015,
  author = {Scheffel, Torben and Harder, Jannis and Decker, Norman},
  file = {:Users/Alex/Documents/Mendeley Desktop/Scheffel, Harder, Decker/Coniras Use cases classification/Scheffel, Harder, Decker - 2015 - Coniras Use cases classification.pdf:pdf},
  title = {{Coniras Use cases classification}},
  year = {2015}
}
@article{Lattner2004,
  abstract = {This paper describes LLVM (Low Level Virtual Machine), a compiler framework designed to support transparent, life-long program analysis and transformation for arbitrary pro-grams, by providing high-level information to compiler transformations at compile-time, link-time, run-time, and in idle time between runs. LLVM defines a common, low-level code representation in Static Single Assignment (SSA) form, with several novel features: a simple, language-independent type-system that exposes the primitives commonly used to implement high-level language features; an instruction for typed address arithmetic; and a simple mechanism that can be used to implement the exception handling features of high-level languages (and setjmp/longjmp in C) uniformly and efficiently. The LLVM compiler framework and code representation together provide a combination of key capa-bilities that are important for practical, lifelong analysis and transformation of programs. To our knowledge, no existing compilation approach provides all these capabilities. We de-scribe the design of the LLVM representation and compiler framework, and evaluate the design in three ways: (a) the size and effectiveness of the representation, including the type information it provides; (b) compiler performance for several interprocedural problems; and (c) illustrative exam-ples of the benefits LLVM provides for several challenging compiler problems.},
  author = {Lattner, Chris and Adve, Vikram},
  doi = {10.1109/CGO.2004.1281665},
  file = {:Users/Alex/Documents/Mendeley Desktop/Lattner, Adve/LLVM A compilation framework for lifelong program analysis {\&} transformation/Lattner, Adve - 2004 - LLVM A compilation framework for lifelong program analysis {\&} transformation.pdf:pdf},
  isbn = {0769521029},
  issn = {1053587X},
  journal = {International Symposium on Code Generation and Optimization, CGO},
  number = {c},
  pages = {75--86},
  title = {{LLVM: A compilation framework for lifelong program analysis {\&} transformation}},
  year = {2004}
}
@misc{Pike,
  author = {Pike, Lee},
  file = {:Users/Alex/Documents/Mendeley Desktop/Pike/Copilot A hard real-time runtime monitor/Pike - Unknown - Copilot A hard real-time runtime monitor.ppt:ppt},
  title = {{Copilot: A hard real-time runtime monitor}}
}
@misc{Pnueli77,
  abstract = {A Unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two formal systems are presented for providig a basis for temporal reasoning. One forms a formalisation of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb, and is particularlly suitable for reasoning about concurrent programs.},
  author = {Pnueli, Amir},
  booktitle = {The 18th IEEE Symposium on Foundation of Computer Science},
  doi = {10.1109/SFCS.1977.32},
  file = {:Users/Alex/Documents/Mendeley Desktop/Pnueli/The Temporal Logic of Programs/Pnueli - 1977 - The Temporal Logic of Programs.pdf:pdf},
  issn = {0272-5428},
  pages = {46--57},
  title = {{The Temporal Logic of Programs}},
  year = {1977}
}
@inproceedings{Ouaknine2005,
  abstract = {Metric temporal logic (MTL) is a prominent specification formalism for real-time systems. In this paper, we show that the satisfiability problem for MTL over finite timed words is decidable, with non-primitive recursive complexity. We also consider the model-checking problem for MTL: whether all words accepted by a given Alur-Dill timed automaton satisfy a given MTL formula. We show that this problem is decidable over finite words. Over infinite words, we show that model checking the safety fragment of MTL-which includes invariance and time-bounded response properties-is also decidable. These results are quite surprising in that they contradict various claims to the contrary that have appeared in the literature. The question of the decidability of MTL over infinite words remains open.},
  author = {Ouaknine, J. and Worrell, J.},
  booktitle = {20th Annual IEEE Symposium on Logic in Computer Science (LICS' 05)},
  doi = {10.1109/LICS.2005.33},
  file = {:Users/Alex/Documents/Mendeley Desktop/Ouaknine, Worrell/On the Decidability of Metric Temporal Logic/Ouaknine, Worrell - 2005 - On the Decidability of Metric Temporal Logic.pdf:pdf},
  isbn = {0-7695-2266-1},
  issn = {1043-6871},
  pages = {188--197},
  publisher = {IEEE},
  title = {{On the Decidability of Metric Temporal Logic}},
  url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1509223},
  year = {2005}
}
@article{Zhou2014a,
  author = {Zhou, Jingwen and Chen, Zhenbang and Wang, Ji and Zheng, Zibin and Dong, Wei},
  doi = {10.1109/ISSREW.2014.84},
  file = {:Users/Alex/Documents/Mendeley Desktop/Zhou et al/A Runtime Verification Based Trace-Oriented Monitoring Framework for Cloud Systems/Zhou et al. - 2014 - A Runtime Verification Based Trace-Oriented Monitoring Framework for Cloud Systems.pdf:pdf},
  isbn = {978-1-4799-7377-4},
  journal = {2014 IEEE International Symposium on Software Reliability Engineering Workshops},
  keywords = {-trace-oriented monitoring,cloud computing,failure detection,runtime verification},
  pages = {152--155},
  title = {{A Runtime Verification Based Trace-Oriented Monitoring Framework for Cloud Systems}},
  url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6983830},
  year = {2014}
}
@article{Pike2006,
  author = {Pike, Lee and Shields, Mark and Matthews, John},
  doi = {10.1145/1217975.1217977},
  file = {:Users/Alex/Documents/Mendeley Desktop/Pike, Shields, Matthews/A Verifying Core for a Cryptographic Language Compiler/Pike, Shields, Matthews - 2006 - A Verifying Core for a Cryptographic Language Compiler.pdf:pdf},
  isbn = {0978849302},
  journal = {ACL2 Workshop},
  keywords = {acl2,certification,certifying compiler,compiler,cryptography,high-assurance,optimizing,verifying compiler},
  pages = {1--10},
  title = {{A Verifying Core for a Cryptographic Language Compiler}},
  year = {2006}
}
@incollection{Raskin1997,
  author = {Raskin, Jean-Fran{\c{c}}ois and Schobbens, Pierre-yves},
  doi = {10.1007/BFb0014711},
  file = {:Users/Alex/Documents/Mendeley Desktop/Raskin, Schobbens/State clock logic A decidable real-time logic/Raskin, Schobbens - 1997 - State clock logic A decidable real-time logic.pdf:pdf},
  pages = {33--47},
  title = {{State clock logic: A decidable real-time logic}},
  url = {http://link.springer.com/10.1007/BFb0014711},
  year = {1997}
}
@article{Bai2015,
  author = {Bai, Jia-Ju and Liu, Hu-Qiu and Wang, Yu-Ping and Hu, Shi-Min},
  doi = {10.1109/COMPSAC.2015.24},
  file = {:Users/Alex/Documents/Mendeley Desktop/Bai et al/Complete Runtime Tracing for Device Drivers Based on LLVM/Bai et al. - 2015 - Complete Runtime Tracing for Device Drivers Based on LLVM.pdf:pdf},
  isbn = {978-1-4673-6564-2},
  journal = {2015 IEEE 39th Annual Computer Software and Applications Conference},
  keywords = {device drivers,llvm,runtime tracing,testing},
  pages = {200--209},
  title = {{Complete Runtime Tracing for Device Drivers Based on LLVM}},
  url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=7273619},
  year = {2015}
}
@article{Necula2002,
  abstract = {This paper describes the CIntermediate Language: a high- level representation along with a set of tools that permit easy analysis and source-to-source transformation of C programs. Compared to C, CIL has fewer constructs. It breaks down certain com- plicated constructs of C into simpler ones, and thus it works at a lower level than abstract-syntax trees. But CIL is also more high-level than typical intermediate languages (e.g., three-address code) designed for compilation. As a result, what we have is a representation that makes it easy to analyze and manipulate C programs, and emit them in a form that resembles the original source. Moreover, it comes with a front-end that translates to CIL not only ANSI C programs but also those using Microsoft C or GNU C extensions. We describe the structure of CIL with a focus on how it disambiguates those features of C that we found to be most confusing for program anal- ysis and transformation.We also describe a whole-program merger based on structural type equality, allowing a complete project to be viewed as a single compilation unit. As a representative application of CIL, we show a transformation aimed at making code immune to stack-smashing at- tacks. We are currently using CIL as part of a system that analyzes and instruments C programs with run-time checks to ensure type safety. CIL has served us very well in this project, and we believe it can usefully be applied in other situations as well.},
  author = {Necula, George C. and McPeak, Scott and Rahul, Shree P. and Weimer, Westley},
  doi = {10.1007/3-540-45937-5_16},
  file = {:Users/Alex/Documents/Mendeley Desktop/Necula et al/CIL Intermediate language and tools for analysis and transformation of C programs/Necula et al. - 2002 - CIL Intermediate language and tools for analysis and transformation of C programs.pdf:pdf},
  isbn = {3540433694},
  issn = {16113349},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  pages = {213--228},
  title = {{CIL: Intermediate language and tools for analysis and transformation of C programs}},
  volume = {2304},
  year = {2002}
}
@article{Weinmann2013,
  author = {Weinmann, Andreas},
  file = {:Users/Alex/Documents/Mendeley Desktop/Weinmann/AUTOSAR und Echtzeit/Weinmann - 2013 - AUTOSAR und Echtzeit.pdf:pdf},
  title = {{AUTOSAR und Echtzeit}},
  year = {2013}
}
@article{Lamport1978,
  abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
  archivePrefix = {arXiv},
  arxivId = {10614036},
  author = {Lamport, Leslie},
  doi = {10.1145/359545.359563},
  eprint = {10614036},
  file = {:Users/Alex/Documents/Mendeley Desktop/Lamport/Time, Clocks, and the Ordering of Events in a Distributed System/Lamport - 1978 - Time, Clocks, and the Ordering of Events in a Distributed System.pdf:pdf},
  isbn = {0262133865},
  issn = {00010782},
  journal = {Communications of the ACM},
  keywords = {clock synchronization,computer networks,distributed systems,multiprocess},
  number = {7},
  pages = {558--565},
  pmid = {10802651},
  title = {{Time, Clocks, and the Ordering of Events in a Distributed System}},
  url = {http://delivery.acm.org.proxy.lib.pdx.edu/10.1145/360000/359563/p558-lamport.pdf?ip=131.252.96.28{\&}id=359563{\&}acc=ACTIVE SERVICE{\&}key=B63ACEF81C6334F5.CA8B0988038A4DF4.4D4702B0C3E38B35.4D4702B0C3E38B35{\&}CFID=744655214{\&}CFTOKEN=36213872{\&}{\_}{\_}acm{\_}{\_}=1452760285{\_}b7c0f},
  volume = {21},
  year = {1978}
}
@article{Ball2002,
  author = {Ball, Thomas and Rajamani, Sriram K.},
  file = {:Users/Alex/Documents/Mendeley Desktop/Ball, Rajamani/SLIC A Specification Language for Interface Checking (of C)/Ball, Rajamani - 2002 - SLIC A Specification Language for Interface Checking (of C).pdf:pdf},
  pages = {1--12},
  title = {{SLIC: A Specification Language for Interface Checking (of C)}},
  year = {2002}
}
@unpublished{Decker2016,
  author = {Decker, Normann and Thoma, Daniel and Harder, Jannis},
  file = {:Users/Alex/Documents/Mendeley Desktop/Decker, Thoma, Harder/TESSLA — A Temporal Stream-based Specification Language/Decker, Thoma, Harder - 2016 - TESSLA — A Temporal Stream-based Specification Language.pdf:pdf},
  pages = {1--16},
  title = {{TESSLA — A Temporal Stream-based Specification Language}},
  year = {2016}
}
@incollection{Maler2004,
  abstract = {In this paper we introduce a variant of temporal logic tailored for specifying desired properties of continuous signals. The logic is based on a bounded subset of the real-time logic mitl, augmented with a static mapping from continuous domains into propositions. From formulae in this logic we create automatically property monitors that can check whether a given signal of bounded length and finite variability satisfies the property. A prototype implementation of this procedure was used to check properties of simulation traces generated by Matlab/Simulink.},
  author = {Maler, Oded and Nickovic, Dejan},
  booktitle = {Formal Techniques, Modelling and Analysis of Timed and Fault-Tolerant Systems},
  doi = {10.1007/978-3-540-30206-3_12},
  file = {:Users/Alex/Documents/Mendeley Desktop/Maler et al/Monitoring Temporal Properties of Continuous Signals/Maler et al. - 2004 - Monitoring Temporal Properties of Continuous Signals.pdf:pdf},
  isbn = {978-3-540-23167-7},
  issn = {03029743},
  pages = {152--166},
  title = {{Monitoring Temporal Properties of Continuous Signals}},
  url = {http://www.springerlink.com/content/j2bkq0uxpv5lwtaf http://link.springer.com/10.1007/978-3-540-30206-3{\_}12},
  year = {2004}
}
@article{Wu2016,
  abstract = {Call traces, i.e., sequences of function calls and returns, are fun-damental to a wide range of program analyses such as bug repro-duction, fault diagnosis, performance analysis, and many others. The conventional approach to collect call traces that instruments each function call and return site incurs large space and time over-head. Our approach aims at reducing the recording overheads by instrumenting only a small amount of call sites while keeping the capability of recovering the full trace. We propose a call trace model and a logged call trace model based on an LL(1) grammar, which enables us to define the criteria of a feasible solution to call trace collection. Based on the two models, we prove that to collect call traces with minimal instrumentation is an NP-hard problem. We then propose an efficient approach to obtaining a suboptimal solu-tion. We implemented our approach as a tool Casper and evaluated it using the DaCapo benchmark suite. The experiment results show that our approach causes significantly lower runtime (and space) overhead than two state-of-the-arts approaches.},
  author = {Wu, Rongxin and Xiao, Xiao and Cheung, Shing-Chi and Zhang, Hongyu and Zhang, Charles},
  doi = {10.1145/2837614.2837619},
  file = {:Users/Alex/Documents/Mendeley Desktop/Wu et al/Casper An Efficient Approach to Call Trace Collection/Wu et al. - 2016 - Casper An Efficient Approach to Call Trace Collection.pdf:pdf},
  isbn = {9781450335492},
  issn = {07308566},
  keywords = {Algorithms,D25 [Testing and Debug-ging],Instrumentation,Overhead,Performance Keywords Call Trace,Program Analysis,Tracing General Terms Theory},
  pages = {678--690},
  title = {{Casper: An Efficient Approach to Call Trace Collection}},
  year = {2016}
}
@article{Chen2009a,
  abstract = {Analysis of execution traces plays a fundamental role in many program analysis approaches. Execution traces are frequently parametric, i.e., they contain events with parameter bindings. Each parametric trace usually consists of many trace slices merged together, each slice corresponding to a parameter binding. Several techniques have been proposed to analyze parametric traces, but they have limitations: some in the specification formalism, others in the type of traces they support; moreover, they share common notions, intuitions, even techniques and algorithms, suggesting that a fundamental understanding of parametric trace analysis is needed. This foundational paper gives the first solution to parametric trace analysis that is unrestricted by the type of parametric properties or traces that can be analyzed. First, a general purpose parametric trace slicing technique is discussed, which takes each event in the parametric trace and distributes it to its corresponding trace slices. This parametric trace slicing technique can be used in combination with any conventional, non-parametric trace analysis, by applying the latter on each trace slice. An online monitoring technique is then presented based on the slicing technique, providing a logic-independent solution to runtime verification of parametric properties. The presented monitoring technique has been implemented and extensively evaluated. The results confirm that the generality of the discussed techniques does not come at a performance expense when compared with existing monitoring systems.},
  author = {Chen, Feng and Roşu, Grigore},
  doi = {10.1007/978-3-642-00768-2_23},
  file = {:Users/Alex/Documents/Mendeley Desktop/Chen, Roşu/Parametric trace slicing and monitoring/Chen, Roşu - 2009 - Parametric trace slicing and monitoring.pdf:pdf},
  isbn = {3642007678},
  issn = {03029743},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  pages = {246--261},
  title = {{Parametric trace slicing and monitoring}},
  volume = {5505 LNCS},
  year = {2009}
}
@article{Kiczales2001,
  abstract = {AspectJ is a simple and practical aspect-oriented extension to Java.. With just a few new constructs, AspectJ provides support for modular implementation of a range of crosscutting concerns. In AspectJs dynamic join point model, join points are well-defined points in the execution of the program; pointcuts are collections of join points; advice are special method-like constructs that can be attached to pointcuts; and aspects are modular units of crosscutting implementation, comprising pointcuts, advice, and ordinary Java member declarations. AspectJ code is compiled into standard Java bytecode. Simple extensions to existing Java development environments make it possible to browse the crosscutting structure of aspects in the same kind of way as one browses the inheritance structure of classes. Several examples show that AspectJ is powerful, and that programs written using it are easy to understand.},
  author = {Kiczales, Gregor and Hilsdale, Erik and Hugunin, Jim and Kersten, Mik and Palm, Jeffrey and Griswold, William G},
  doi = {10.1007/3-540-45337-7_18},
  isbn = {3540422064},
  issn = {03029743},
  journal = {ECOOP 2001 — Object-Oriented Programming: 15th European Conference Budapest, Hungary, June 18–22, 2001 Proceedings},
  number = {4},
  pages = {327--354},
  title = {{An Overview of AspectJ}},
  url = {http://www.springerlink.com/index/mc9xermkrav48ff1.pdf$\backslash$nhttp://link.springer.com/10.1007/3-540-45337-7{\_}18},
  volume = {2072},
  year = {2001}
}
@article{Clarke82,
  abstract = {We have shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification. We believe that this approach may in the long run turn out to be quite practical. Since synchronization skeletons are, in general, quite small, the potentially exponential behavior of our algorithm need not be an insurmountable obstacle. Much additional research will be needed, however, to make the approach feasible in practice.},
  author = {Clarke, Edmund M and Emerson, E Allen},
  doi = {10.1007/BFb0025774},
  file = {:Users/Alex/Documents/Mendeley Desktop/Clarke, Emerson/Design and synthesis of synchronization skeletons using branching time temporal logic/Clarke, Emerson - 1982 - Design and synthesis of synchronization skeletons using branching time temporal logic.pdf:pdf},
  isbn = {354011212X},
  issn = {08905401},
  journal = {Logics of Programs},
  pages = {52--71},
  title = {{Design and synthesis of synchronization skeletons using branching time temporal logic}},
  url = {http://www.springerlink.com/index/w1778u28166t2677.pdf$\backslash$nhttp://repository.cmu.edu/cgi/viewcontent.cgi?article=1451{\&}context=compsci},
  volume = {131},
  year = {1982}
}
@incollection{Ouaknine2008,
  abstract = {Metric Temporal Logic (MTL) is a widely-studied real-time extension of Linear Temporal Logic. In this paper we survey results about the complexity of the satisfiability and model checking problems for fragments of MTL with respect to different semantic models.We show that these fragments have widely differing complexities: from polynomial space to non-primitive recursive and even undecidable. However we show that the most commonly occurring real-time properties, such as invariance and bounded response, can be expressed in fragments of MTL for which model checking, if not satisfiability, can be decided in polynomial or exponential space.},
  address = {Berlin, Heidelberg},
  author = {Ouaknine, Jo{\"{e}}l and Worrell, James},
  booktitle = {Formal Modeling and Analysis of Timed Systems},
  doi = {10.1007/978-3-540-85778-5_1},
  file = {:Users/Alex/Documents/Mendeley Desktop/Ouaknine, Worrell/Some Recent Results in Metric Temporal Logic/Ouaknine, Worrell - 2008 - Some Recent Results in Metric Temporal Logic.pdf:pdf},
  isbn = {354085777X},
  issn = {03029743},
  pages = {1--13},
  publisher = {Springer Berlin Heidelberg},
  title = {{Some Recent Results in Metric Temporal Logic}},
  url = {http://link.springer.com/10.1007/978-3-540-85778-5{\_}1},
  volume = {5215 LNCS},
  year = {2008}
}
@article{Bauer2006,
  abstract = {This paper presents SALT. SALT is a general purpose specification and assertion language developed for creating concise temporal specifications to be used in industrial verification environments. It incorporates ideas of existing approaches, such as specification patterns, but also provides nested scopes, exceptions, support for regular expressions and real-time. The latter is needed in particular for verification tasks to do with reactive systems imposing strict execution times and dead-lines. However, unlike other formalisms used for temporal specification of properties, SALT does not target a specific domain. The paper details on the design rationale, syntax and semantics of SALT in terms of a translation to temporal (real-time) logic, as well as on the realisation in form of a compiler. Our results will show that the higher level of abstraction introduced with SALT does not deprave the efficiency of the subsequent verification tools - rather, on the contrary. {\textcopyright} Springer-Verlag Berlin Heidelberg 2006.},
  author = {Bauer, Andreas and Leucker, Martin and Streit, Jonathan},
  file = {:Users/Alex/Documents/Mendeley Desktop/Bauer, Leucker, Streit/SALT - Structured assertion language for temporal logic/Bauer, Leucker, Streit - 2006 - SALT - Structured assertion language for temporal logic.pdf:pdf},
  isbn = {3540474609},
  issn = {03029743},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  pages = {757--775},
  title = {{SALT - Structured assertion language for temporal logic}},
  volume = {4260 LNCS},
  year = {2006}
}
@inproceedings{Marek2012,
  author = {Marek, L and Zheng, Y and Ansaloni, D},
  booktitle = {Proceedings of the 11th annual international conference on Aspect-oriented Software Development},
  doi = {10.1145/2162049.2162077},
  file = {:Users/Alex/Documents/Mendeley Desktop/Marek, Zheng, Ansaloni/DiSL a domain-specific language for bytecode instrumentation/Marek, Zheng, Ansaloni - 2012 - DiSL a domain-specific language for bytecode instrumentation.pdf:pdf},
  isbn = {9781450310925},
  keywords = {analysis,aspect-oriented programming,bytecode instrumentation,dynamic program,jvm},
  pages = {239--250},
  title = {{DiSL: a domain-specific language for bytecode instrumentation}},
  url = {http://dl.acm.org/citation.cfm?id=2162077},
  year = {2012}
}
@article{Fischmeister2010,
  abstract = {Software instrumentation is a key technique in many stages of the development process. It is particularly important for debugging embedded systems. Instrumented programs produce data traces which enable the developer to locate the origins of misbehaviors in the system under test. However, producing data traces incurs runtime overhead in the form of additional computation resources for capturing and copying the data. The instrumentation may therefore interfere with the system's timing and perturb its behavior. In this work, we propose an instrumentation technique for applications with temporal constraints, specifically targeting background/foreground or cyclic executive systems. Our framework permits reasoning about space and time and enables the composition of software instrumentations. In particular, we propose a definition for trace reliability, which enables us to instrument real-time applications which aggressively push their time budgets. Using the framework, we present a method with low perturbation by optimizing the number of insertion points and trace buffer size with respect to code size and time budgets. Finally, we apply the theory to two concrete case studies: we instrument the OpenEC firmware for the keyboard controller of the One Laptop Per Child project, as well as an implementation of a flash file system.},
  author = {Fischmeister, Sebastian and Lam, Patrick},
  doi = {10.1109/TII.2010.2068304},
  file = {:Users/Alex/Documents/Mendeley Desktop/Fischmeister, Lam/Time-aware instrumentation of embedded software/Fischmeister, Lam - 2010 - Time-aware instrumentation of embedded software.pdf:pdf},
  isbn = {1551-3203 VO - 6},
  issn = {15513203},
  journal = {IEEE Transactions on Industrial Informatics},
  keywords = {Debugging,instrumentation,real-time systems,tracing},
  number = {4},
  pages = {652--663},
  title = {{Time-aware instrumentation of embedded software}},
  volume = {6},
  year = {2010}
}
@article{Dwyer1999,
  abstract = {Model checkers and other finite-state verification tools allow developers to detect certain kinds of errors automatically. Nevertheless, the transition of this technology from research to practice has been slow. While there are a number of potential causes for reluctance to adopt such formal methods, we believe that a primary cause is that practitioners are unfamiliar with specification processes, notations, and strategies. In a recent paper, we proposed a pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification. Since then, we have carried out a survey of available specifications, collecting over 500 examples of property specifications. We found that most are instances of our proposed patterns. Furthermore, we have updated our pattern system to accommodate new patterns and variations of existing patterns encountered in this survey. This paper reports the results of the survey and the current status of our pattern system.},
  author = {Dwyer, M.B. and Avrunin, G.S. and Corbett, J.C.},
  doi = {10.1145/302405.302672},
  file = {:Users/Alex/Documents/Mendeley Desktop/Dwyer, Avrunin, Corbett/Patterns in property specifications for finite-state verification/Dwyer, Avrunin, Corbett - 1999 - Patterns in property specifications for finite-state verification.pdf:pdf},
  isbn = {1-58113-074-0},
  issn = {0270-5257},
  journal = {Proceedings of the 1999 International Conference on Software Engineering (IEEE Cat. No.99CB37002)},
  keywords = {finite-state,patterns},
  pages = {411--420},
  title = {{Patterns in property specifications for finite-state verification}},
  year = {1999}
}
@inproceedings{Hall2011,
  address = {Cham},
  author = {Hall{\'{e}}, Sylvain},
  booktitle = {Runtime Verification - 16th International Conference, Madrid},
  doi = {10.1007/978-3-319-46982-9_6},
  editor = {Falcone, Yli{\`{e}}s and S{\'{a}}nchez, C{\'{e}}sar},
  file = {:Users/Alex/Documents/Mendeley Desktop/Hall{\'{e}}/When RV Meets CEP/Hall{\'{e}} - 2016 - When RV Meets CEP.pdf:pdf},
  isbn = {978-3-319-46981-2},
  number = {April},
  pages = {68--91},
  publisher = {Springer International Publishing},
  series = {Lecture Notes in Computer Science},
  title = {{When RV Meets CEP}},
  url = {http://link.springer.com/10.1007/978-3-319-46982-9 http://link.springer.com/10.1007/978-3-319-46982-9{\_}6},
  volume = {10012},
  year = {2016}
}
@article{Cantrill2004,
  abstract = {This paper presents DTrace, a new facility for dynamic instrumentation of production systems. DTrace features the ability to dynamically instrument both user-level and kernel-level software in a unified and absolutely safe fashion. When not explicitly enabled, DTrace has zero probe effectthe system operates exactly as if DTrace were not present at all. DTrace allows for many tens of thousands of instrumentation points, with even the smallest of systems offering on the order of 30,000 such points in the kernel alone. We have developed a C-like high-level control language to describe the predicates and actions at a given point of instrumentation. The language features user-defined variables, including thread-local variables and associative arrays. To eliminate the need for most postprocessing, the facility features a scalable mechanism for aggregating data and a mechanism for speculative tracing. DTrace has been integrated into the Solaris operating system and has been used to find serious systemic performance problems on production systemsproblems that could not be found using pre-existing facilities.},
  author = {Cantrill, Bryan M and Shapiro, Michael W and Leventhal, Adam H},
  doi = {10.1177/003754979406300206},
  file = {:Users/Alex/Documents/Mendeley Desktop/Cantrill, Shapiro, Leventhal/DTrace Dynamic Instrumentation of Production Systems/Cantrill, Shapiro, Leventhal - 2004 - DTrace Dynamic Instrumentation of Production Systems.pdf:pdf},
  issn = {0037-5497},
  journal = {Development},
  number = {July 2002},
  pages = {15--28},
  title = {{DTrace: Dynamic Instrumentation of Production Systems}},
  url = {http://www.usenix.org/event/usenix04/tech/general/full{\_}papers/cantrill/cantrill{\_}html/},
  year = {2004}
}
@article{Navabpour2013,
  abstract = {We introduce the tool RiTHM (Runtime Time-triggered Heterogeneous Monitoring). RiTHM takes a C program under inspection and a set of LTL properties as input and generates an instrumented C program that is verified at run time by a time-triggered monitor. RiTHM provides two techniques based on static analysis and control theory to minimize instrumentation of the input C program and monitoring intervention. The monitor's verification decision procedure is sound and complete and exploits the GPU many-core technology to speedup and encapsulate monitoring tasks.},
  author = {Navabpour, Samaneh and Joshi, Yogi and Wu, Wallace and Berkovich, Shay and Medhat, Ramy and Bonakdarpour, Borzoo and Fischmeister, Sebastian},
  doi = {10.1145/2491411.2494596},
  file = {:Users/Alex/Documents/Mendeley Desktop/Navabpour et al/RiTHM A Tool for Enabling Time-triggered Runtime Verification for C Programs/Navabpour et al. - 2013 - RiTHM A Tool for Enabling Time-triggered Runtime Verification for C Programs.pdf:pdf},
  isbn = {978-1-4503-2237-9},
  journal = {Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering},
  keywords = {Embedded systems,Overhead predictability and containment,Real-time systems,Runtime monitoring},
  pages = {603--606},
  title = {{RiTHM: A Tool for Enabling Time-triggered Runtime Verification for C Programs}},
  url = {http://doi.acm.org/10.1145/2491411.2494596},
  year = {2013}
}
@article{Bodirsky2007,
  abstract = {A relational structure is a core, if all its endomorphisms are embeddings. This notion is important for computational complexity classification of constraint satisfaction problems. It is a fundamental fact that every finite structure has a core, i.e., has an endomorphism such that the structure induced by its image is a core; moreover, the core is unique up to isomorphism. Weprove that every omega -categorical structure has a core. Moreover, every omega-categorical structure is homomorphically equivalent to a model-complete core, which is unique up to isomorphism, and which is finite or omega -categorical. We discuss consequences for constraint satisfaction with omega -categorical templates.},
  author = {Bodirsky, Manuel},
  doi = {10.2168/LMCS-3},
  file = {:Users/Alex/Documents/Mendeley Desktop/Bodirsky/Cores of Countably Categorical Structures/Bodirsky - 2007 - Cores of Countably Categorical Structures.pdf:pdf},
  issn = {18605974},
  journal = {Logical Methods in Computer Science},
  keywords = {constraint satisfaction,cores,omega-categorical structures},
  pages = {1--16},
  title = {{Cores of Countably Categorical Structures}},
  url = {http://arxiv.org/abs/cs/0612069},
  volume = {3},
  year = {2007}
}
@article{Pellizzoni2008,
  author = {Pellizzoni, R. and Meredith, P. and Caccamo, M. and Rosu, G.},
  file = {:Users/Alex/Documents/Mendeley Desktop/Pellizzoni et al/Hardware Runtime Monitoring for COTS-based Real-Time Embedded Systems/Pellizzoni et al. - 2008 - Hardware Runtime Monitoring for COTS-based Real-Time Embedded Systems.pdf:pdf},
  journal = {Real-Time Systems Symposium},
  pages = {481--491},
  title = {{Hardware Runtime Monitoring for COTS-based Real-Time Embedded Systems}},
  year = {2008}
}
@article{Koymans1990,
  abstract = {This paper is motivated by the need for a formal specification method for real-time systems. In these systemsquantitative temporal properties play a dominant role. We first characterize real-time systems by giving a classification of such quantitative temporal properties. Next, we extend the usual models for temporal logic by including a distance function to measure time and analyze what restrictions should be imposed on such a function. Then we introduce appropriate temporal operators to reason about such models by turning qualitative temporal operators into (quantitative) metric temporal operators and show how the usual quantitative temporal properties of real-time systems can be expressed in this metric temporal logic. After we illustrate the application of metric temporal logic to real-time systems by several examples, we end this paper with some conclusions.},
  author = {Koymans, Ron},
  doi = {10.1007/BF01995674},
  issn = {09226443},
  journal = {Real-Time Systems},
  number = {4},
  pages = {255--299},
  title = {{Specifying real-time properties with metric temporal logic}},
  volume = {2},
  year = {1990}
}
@article{Pike2010,
  author = {Pike, Lee and Goodloe, Alwyn and Morisset, Robin and Niller, Sebastian},
  doi = {10.1007/978-3-642-16612-9_26},
  file = {:Users/Alex/Documents/Mendeley Desktop/Pike et al/Copilot A hard real-time runtime monitor/Pike et al. - 2010 - Copilot A hard real-time runtime monitor.pdf:pdf},
  isbn = {3642166113},
  issn = {03029743},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  number = {Rv},
  pages = {345--359},
  title = {{Copilot: A hard real-time runtime monitor}},
  volume = {6418 LNCS},
  year = {2010}
}
@article{Chen2007,
  author = {Chen, Feng},
  file = {:Users/Alex/Documents/Mendeley Desktop/Chen/MOP An Efficient and Generic Runtime Verification Framework ∗/Chen - 2007 - MOP An Efficient and Generic Runtime Verification Framework ∗.pdf:pdf},
  isbn = {9781595937865},
  journal = {ACM SIGPLAN Notices},
  keywords = {aspect-oriented program-,ming,monitoring-oriented programming,runtime verification},
  number = {10},
  pages = {569--588},
  title = {{MOP : An Efficient and Generic Runtime Verification Framework ∗}},
  volume = {42},
  year = {2007}
}
@article{Finkbeiner2005,
  abstract = {By collecting statistics over runtime executions of a program we can answer complex queries, such as "what is the average number of packet retransmissions" in a communication protocol, or "how often does process P1 enter the critical section while process P2 waits" in a mutual exclusion algorithm. We present an extension to linear-time temporal logic that combines the temporal specification with the collection of statistical data. By translating formulas of this language to alternating automata we obtain a simple and efficient query evaluation algorithm. We illustrate our approach with examples and experimental results. ?? 2002 Published by Elsevier Science B.V.},
  author = {Finkbeiner, Bernd and Sankaranarayanan, Sriram and Sipma, Henny B.},
  doi = {10.1007/s10703-005-3399-3},
  file = {:Users/Alex/Documents/Mendeley Desktop/Finkbeiner, Sankaranarayanan, Sipma/Collecting statistics over runtime executions/Finkbeiner, Sankaranarayanan, Sipma - 2005 - Collecting statistics over runtime executions.pdf:pdf},
  issn = {09259856},
  journal = {Formal Methods in System Design},
  keywords = {Program profiling,Runtime monitoring,Runtime verification,Specification languages,Temporal logic},
  number = {3 SPEC. ISS.},
  pages = {253--274},
  title = {{Collecting statistics over runtime executions}},
  volume = {27},
  year = {2005}
}
@article{Zhou2014,
  author = {Zhou, Jingwen and Chen, Zhenbang and Wang, Ji and Zheng, Zibin and Lyu, Michael R.},
  doi = {10.1109/CloudCom.2014.79},
  file = {:Users/Alex/Documents/Mendeley Desktop/Zhou et al/Trace Bench An Open Data Set for Trace-Oriented Monitoring/Zhou et al. - 2014 - Trace Bench An Open Data Set for Trace-Oriented Monitoring.pdf:pdf},
  isbn = {978-1-4799-4093-6},
  journal = {2014 IEEE 6th International Conference on Cloud Computing Technology and Science},
  keywords = {-data set,cloud computing,fault injection,generation,trace-oriented monitoring,workload},
  pages = {519--526},
  title = {{Trace Bench: An Open Data Set for Trace-Oriented Monitoring}},
  url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=7037711},
  year = {2014}
}
@article{Havelund2008,
  abstract = {We present in this paper a framework, RMOR, for monitoring the execution of C programs against state machines, expressed in a textual (nongraphical) format in files separate from the program. The state machine language has been inspired by a graphical state machine language RCAT recently developed at the Jet Propulsion Laboratory, as an alternative to using Linear Temporal Logic (LTL) for requirements capture. Transitions between states are labeled with abstract event names and Boolean expressions over such. The abstract events are connected to code fragments using an aspect-oriented pointcut language similar to ASPECTJ's or ASPECTC's pointcut language. The system is implemented in the C analysis and transformation package CIL, and is programmed in OCAML, the implementation language of CIL. The work is closely related to the notion of stateful aspects within aspect-oriented programming, where pointcut languages are extended with temporal assertions over the execution trace.},
  author = {Havelund, Klaus},
  doi = {10.1007/978-3-540-68524-1_3},
  file = {:Users/Alex/Documents/Mendeley Desktop/Havelund/Runtime Verification of C Programs/Havelund - 2008 - Runtime Verification of C Programs.pdf:pdf},
  isbn = {9783540685142},
  issn = {03029743},
  title = {{Runtime Verification of C Programs}},
  year = {2008}
}
@article{Decker2014,
  abstract = {This paper presents a framework to ensure the correctness of service-oriented architectures based on runtime verification techniques. Traditionally, the reliability of safety critical systems is ensured by testing the complete system including all subsystems. When those systems are designed as service-oriented architectures, and independently developed subsystems are composed to new systems at runtime, this approach is no longer viable. Instead, the presented framework uses runtime monitors synthesised from high-level specifications to ensure safety constraints. The framework has been designed for the interconnection of medical devices in the operating room. As a case study, the framework is applied to the interconnection of an ultrasound dissector and a microscope. Benchmarks show that the monitoring overhead is negligible in this setting.},
  author = {Decker, Normann and Kuhn, Franziska and Thoma, Daniel},
  doi = {10.1109/ISSRE.2014.16},
  file = {:Users/Alex/Documents/Mendeley Desktop/Decker, Kuhn, Thoma/Runtime verification of web services for interconnected medical devices/Decker, Kuhn, Thoma - 2014 - Runtime verification of web services for interconnected medical devices.pdf:pdf},
  isbn = {978-1-4799-6033-0},
  issn = {10719458},
  journal = {Proceedings - International Symposium on Software Reliability Engineering, ISSRE},
  keywords = {Automata,LTL,Medical Devices,Runtime Verification,SMT,Web Services},
  pages = {235--244},
  title = {{Runtime verification of web services for interconnected medical devices}},
  year = {2014}
}
@article{Caspi1987,
  abstract = {LUSTRE is a synchronous data-flow language for programming systems which interact with their environments in real-time. After an informal presentation of the language, we describe its semantics by means of structural inference rules. Moreover, we show how to use this semantics in order to generate efficient sequential code, namely, a finite state automaton which represents the control of the program. Formal rules for program transformation are also presented.},
  author = {Caspi, P and Pilaud, D and Halbwachs, N. and Plaice, J a},
  doi = {10.1145/41625.41641},
  file = {:Users/Alex/Documents/Mendeley Desktop/Caspi et al/LUSTRE a declarative language for real-time programming/Caspi et al. - 1987 - LUSTRE a declarative language for real-time programming.pdf:pdf},
  isbn = {0897912152},
  journal = {Proceedings of the 14th ACM SIGACT-SIGPLAN symposium on Principles of programming languages - POPL '87},
  pages = {178--188},
  title = {{LUSTRE: a declarative language for real-time programming}},
  url = {http://portal.acm.org/citation.cfm?doid=41625.41641},
  year = {1987}
}
@article{Fidge1988,
  abstract = {Timestamping is a common method of totally ordering events in concurrent programs. However, for applications requiring access to the global state, a total ordering is inappropriate. This paper presents algorithms for timestamping events in both synchronous and asynchronous message-passing programs that allow for access to the partial ordering inherent in a parallel system. The algorithms do not hcnage the communications graph or require a central timestamp issuing authority.},
  archivePrefix = {arXiv},
  arxivId = {10614036},
  author = {Fidge, Colin J},
  doi = {10.1145/359545.359563},
  eprint = {10614036},
  file = {:Users/Alex/Documents/Mendeley Desktop/Fidge/Timestamps in Message-Passing Systems That Preserve the Partial Ordering/Fidge - 1988 - Timestamps in Message-Passing Systems That Preserve the Partial Ordering.pdf:pdf},
  isbn = {0262133865},
  issn = {00010782},
  journal = {Proc of the 11th Australian Computer Science Conference ACSC88},
  keywords = {3,and phrases,clock vector,concurrent programming,cr categories,d,l,logical clocks,message-passing,timestamps},
  number = {1},
  pages = {56--66},
  pmid = {10802651},
  title = {{Timestamps in Message-Passing Systems That Preserve the Partial Ordering}},
  url = {http://sky.scitech.qut.edu.au/{~}fidgec/Publications/fidge88a.pdf},
  volume = {10},
  year = {1988}
}
@incollection{Alur2004,
  abstract = {Model checking of linear temporal logic (LTL) specifications with respect to pushdown systems has been shown to be a useful tool for analysis of programs with potentially recursive procedures. LTL, however, can specify only regular properties, and properties such as correctness of procedures with respect to pre and post conditions, that require matching of calls and returns, are not regular. We introduce a temporal logic of calls and returns (CaRet) for specification and algorithmic verification of correctness requirements of structured programs. The formulas of CaRet are interpreted over sequences of propositional valuations tagged with special symbols call and ret. Besides the standard global temporal modalities, CaRet admits the abstract-next operator that allows a path to jump from a call to the matching return. This operator can be used to specify a variety of non-regular properties such as partial and total correctness of program blocks with respect to pre and post conditions. The abstract versions of the other temporal modalities can be used to specify regular properties of local paths within a procedure that skip over calls to other procedures. CaRet also admits the caller modality that jumps to the most recent pending call, and such caller modalities allow specification of a variety of security properties that involve inspection of the call-stack. Even though verifying context-free properties of pushdown systems is undecidable, we show that model checking CaRet formulas against a pushdown model is decidable. We present a tableau construction that reduces our model checking problem to the emptiness problem for a Bchi pushdown system. The complexity of model checking CaRet formulas is the same as that of checking LTL formulas, namely, polynomial in the model and singly exponential in the size of the specification.},
  author = {Alur, Rajeev and Etessami, Kousha and Madhusudan, P},
  booktitle = {Tacas},
  doi = {10.1007/978-3-540-24730-2_35},
  file = {:Users/Alex/Documents/Mendeley Desktop/Alur, Etessami, Madhusudan/A Temporal Logic of Nested Calls and Returns/Alur, Etessami, Madhusudan - 2004 - A Temporal Logic of Nested Calls and Returns.pdf:pdf},
  isbn = {3-540-21299-X},
  issn = {03029743},
  number = {Tacas},
  pages = {467--481},
  title = {{A Temporal Logic of Nested Calls and Returns}},
  url = {http://www.springerlink.com/index/cxfk43g5wqdxt0vp.pdf http://link.springer.com/10.1007/978-3-540-24730-2{\_}35},
  volume = {2988},
  year = {2004}
}
@article{Mostafa2015,
  author = {Mostafa, Menna and Bonakdarpour, Borzoo},
  doi = {10.1109/IPDPS.2015.95},
  file = {:Users/Alex/Documents/Mendeley Desktop/Mostafa, Bonakdarpour/Decentralized Runtime Verification of LTL Specifications in Distributed Systems/Mostafa, Bonakdarpour - 2015 - Decentralized Runtime Verification of LTL Specifications in Distributed Systems.pdf:pdf},
  isbn = {978-1-4799-8649-1},
  journal = {2015 IEEE International Parallel and Distributed Processing Symposium},
  keywords = {-runtime monitoring,Runtime monitoring, Asynchronous distributed syste,asynchronous distributed sys-,formal methods,tems},
  pages = {494--503},
  title = {{Decentralized Runtime Verification of LTL Specifications in Distributed Systems}},
  url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=7161537},
  year = {2015}
}
@article{DAngelo2005,
  abstract = {We present a specification language and algorithms for the online and offline monitoring of synchronous systems including circuits and embedded systems. Such monitoring is useful not only for testing, but also under actual deployment. The specification language is simple and expressive; it can describe both correctness/failure assertions along with interesting statistical measures that are useful for system profiling and coverage analysis. The algorithm for online monitoring of queries in this language follows a partial evaluation strategy: it incrementally constructs output streams from input streams, while maintaining a store of partially evaluated expressions for forward references. We identify a class of specifications, characterized syntactically, for which the algorithm's memory requirement is independent of the length of the input streams. Being able to bound memory requirements is especially important in online monitoring of large input streams. We extend the concepts used in the online algorithm to construct an efficient offline monitoring algorithm for large traces. We have implemented our algorithm and applied it to two industrial systems, the PCI bus protocol and a memory controller. The results demonstrate that our algorithms are practical and that our specification language is sufficiently expressive to handle specifications of interest to industry.},
  author = {D'Angelo, Ben and Sankaranarayanan, Sriram and S{\'{a}}nchez, C{\'{e}}sar and Robinson, Will and Finkbeiner, Bernd and Sipma, Henny B. and Mehrotra, Sandeep and Manna, Zohar},
  doi = {10.1109/TIME.2005.26},
  file = {:Users/Alex/Documents/Mendeley Desktop/D'Angelo et al/LOLA Runtime monitoring of synchronous systems/D'Angelo et al. - 2005 - LOLA Runtime monitoring of synchronous systems.pdf:pdf},
  isbn = {0-7695-2370-6},
  issn = {1530-1311},
  journal = {Proceedings of the International Workshop on Temporal Representation and Reasoning},
  pages = {166--175},
  title = {{LOLA: Runtime monitoring of synchronous systems}},
  year = {2005}
}
@inbook{Faymonville2016,
  address = {Cham},
  author = {Faymonville, Peter and Finkbeiner, Bernd and Schirmer, Sebastian and Torfah, Hazem},
  booktitle = {Runtime Verification: 16th International Conference, RV 2016, Madrid, Spain, September 23--30, 2016, Proceedings},
  doi = {10.1007/978-3-319-46982-9_10},
  editor = {Falcone, Yli{\`{e}}s and S{\'{a}}nchez, C{\'{e}}sar},
  file = {:Users/Alex/Documents/Mendeley Desktop/Faymonville et al/A Stream-Based Specification Language for Network Monitoring/Faymonville et al. - 2016 - A Stream-Based Specification Language for Network Monitoring.pdf:pdf},
  isbn = {978-3-319-46982-9},
  pages = {152--168},
  publisher = {Springer International Publishing},
  title = {{A Stream-Based Specification Language for Network Monitoring}},
  url = {http://dx.doi.org/10.1007/978-3-319-46982-9{\_}10},
  year = {2016}
}
@article{Sigelman2010,
  abstract = {Modern Internet services are often implemented as complex, large-scale distributed systems. These applications are constructed from collections of software modules that may be developed by different teams, perhaps in different programming languages, and could span many thousands of machines across multiple physical facilities. Tools that aid in understanding system behavior and reasoning about performance issues are invaluable in such an environment. Here we introduce the design of Dapper, Googles production distributed systems tracing infrastructure, and describe how our design goals of low overhead, application-level transparency, and ubiquitous deployment on a very large scale system were met. Dapper shares conceptual similarities with other tracing systems, particularly Magpie 3 and X-Trace 12, but certain design choices were made that have been key to its success in our environment, such as the use of sampling and restricting the instrumentation to a rather small number of common libraries. The main goal of this paper is to report on our experience building, deploying and using the system for over two years, since Dappers foremost measure of success has been its usefulness to developer and operations teams. Dapper began as a self-contained tracing tool but evolved into a monitoring platform which has enabled the creation of many different tools, some of which were not anticipated by its designers. We describe a few of the analysis tools that have been built using Dapper, share statistics about its usage within Google, present some example use cases, and discuss lessons learned so far.},
  author = {Sigelman, Benjamin H and Andr, Luiz and Burrows, Mike and Stephenson, Pat and Plakal, Manoj and Beaver, Donald and Jaspan, Saul and Shanbhag, Chandan},
  doi = {dapper-2010-1},
  file = {:Users/Alex/Documents/Mendeley Desktop/Sigelman et al/Dapper , a Large-Scale Distributed Systems Tracing Infrastructure/Sigelman et al. - 2010 - Dapper , a Large-Scale Distributed Systems Tracing Infrastructure.pdf:pdf},
  issn = {{\textless}null{\textgreater}},
  journal = {Google Research},
  number = {April},
  pages = {14},
  title = {{Dapper , a Large-Scale Distributed Systems Tracing Infrastructure}},
  year = {2010}
}
@article{Ehrich2000,
  author = {Ehrich, Hans-Dieter and Caleiro, Carlos},
  file = {:Users/Alex/Documents/Mendeley Desktop/Ehrich, Caleiro/Specifying communication in distributed information systems/Ehrich, Caleiro - 2000 - Specifying communication in distributed information systems.pdf:pdf},
  issn = {0001-5903 (print), 1432-0525 (electronic)},
  journal = {Acta Informatica},
  pages = {1--24},
  title = {{Specifying communication in distributed information systems}},
  url = {http://www.springerlink.com/index/3B94J75EHVCVM0L5.pdf},
  volume = {616},
  year = {2000}
}
@article{Bauer2011,
  abstract = {This paper studies runtime verification of properties expressed either in lineartime temporal logic (LTL) or timed lineartime temporal logic (TLTL). It classifies runtime verification in identifying its distinguishing features to model checking and testing, respectively. It introduces a three-valued semantics (with truth values true, false, inconclusive) as an adequate interpretation as to whether a partial observation of a running system meets an LTL or TLTL property. For LTL, a conceptually simple monitor generation procedure is given, which is optimal in two respects: First, the size of the generated deterministic monitor is minimal, and, second, the monitor identifies a continuously monitored trace as either satisfying or falsifying a property as early as possible. The feasibility of the developed methodology is demontrated using a collection of real-world temporal logic specifications. Moreover, the presented approach is related to the properties monitorable in general and is compared to existing concepts in the literature. It is shown that the set of monitorable properties does not only encompass the safety and co-safety properties but is strictly larger. For TLTL, the same road map is followed by first defining a three-valued semantics. The corresponding construction of a timed monitor is more involved, yet, as shown, possible.},
  author = {Bauer, Andreas and Leucker, Martin and Schallhart, Christian},
  doi = {10.1145/2000799.2000800},
  file = {:Users/Alex/Documents/Mendeley Desktop/Bauer, Leucker, Schallhart/Runtime Verification for LTL and TLTL/Bauer, Leucker, Schallhart - 2011 - Runtime Verification for LTL and TLTL.pdf:pdf},
  isbn = {1049-331X},
  issn = {1049331X},
  journal = {ACM Transactions on Software Engineering and Methodology},
  number = {4},
  pages = {1--64},
  title = {{Runtime Verification for LTL and TLTL}},
  volume = {20},
  year = {2011}
}
@article{LeGuernic1987,
  abstract = {We present an applicative language, SIGNAL, designed to program real-time systems. The language is based on a synchronous notion of time. We assume the execution of operations to have a zero logical time duration ; then, the sequence of communication events determines entirely a temporal reference. The ordering of the runable operations is limited only by the dependencies between the calculi : this is the point of view of data flow languages. SIGNAL is a data flow language (where the potential parallelism is implicit), which permits a structural description of interconnected processes. SIGNAL handles possibly infinite sequences of values (called signals) characterized oy an implicit clock which specifies the relative instants (with respect to other signals) at which these values are available. Specific operators, such as delay, undersampling, deterministic merge, are designed to express temporal relations between different signals : in this way, a SIGNAL program expresses both functional and temporal relationships between all the involved signals. The language is semantically sound, and its declarative style allows to derive, by a simple projection on the commutative field Z/3Z, a complete static calculus of the timing of any SIGNAL process, called its clock calculus. Hence, the language SIGNAL is also a formal system to reason about timing and concurrency. The clock calculus is completed together with the dependency analysis of a given program. This leads to a conditional dependence graph in which the edges may be labelled by the involved clocks. From this graph, we generate code for a sequential machine, but it appears to be the suitable level to study the implementation on a multiprocessor architecture.},
  author = {{Le Guernic}, P and Gautier, T and Besnard, L},
  doi = {10.1007/3-540-18317-5_15},
  file = {:Users/Alex/Documents/Mendeley Desktop/Le Guernic, Gautier, Besnard/SIGNAL{\~{}} a declarative language for synchronous programming of real-time systems/Le Guernic, Gautier, Besnard - 1987 - SIGNAL{\~{}} a declarative language for synchronous programming of real-time systems.pdf:pdf},
  isbn = {978-3-540-18317-4},
  journal = {Functional programming languages and computer architecture},
  pages = {257--277},
  title = {{SIGNAL{\~{}}: a declarative language for synchronous programming of real-time systems}},
  year = {1987}
}
@techreport{Berris2016,
  author = {Berris, Dean Michael and Veitch, Alistair and Heintze, Nevin and Anderson, Eric and Wang, Ning},
  file = {:Users/Alex/Documents/Mendeley Desktop/Berris et al/XRay A Function Call Tracing System/Berris et al. - 2016 - XRay A Function Call Tracing System.pdf:pdf},
  title = {{XRay: A Function Call Tracing System}},
  year = {2016}
}
@article{Soule2010,
  abstract = {Stream processing applications such as algorithmic trading, MPEG processing, and web content analysis are ubiquitous and essential to business and entertainment. Language designers have developed numerous domain-specific languages that are both tailored to the needs of their applications, and optimized for performance on their particular target platforms. Unfortunately, the goals of generality and performance are frequently at odds, and prior work on the formal semantics of stream processing languages does not capture the details necessary for reasoning about implementations. This paper presents Brooklet, a core calculus for stream processing that allows us to reason about how to map languages to platforms and how to optimize stream programs. We translate from three representative languages, CQL, StreamIt, and Sawzall, to Brooklet, and show that the translations are correct. We formalize three popular and vital optimizations, data-parallel computation, operator fusion, and operator re-ordering, and show under which conditions they are correct. Language designers can use Brooklet to specify exactly how new features or languages behave. Language implementors can use Brooklet to show exactly under which circumstances new optimizations are correct. In ongoing work, we are developing an intermediate language for streaming that is based on Brooklet. We are implementing our intermediate language on System S, IBM's high-performance},
  author = {Soul{\'{e}}, Robert and Hirzel, Martin and Grimm, Robert and Gedik, Buǧra and Andrade, Henrique and Kumar, Vibhore and Wu, Kun Lung},
  doi = {10.1007/978-3-642-11957-6_27},
  file = {:Users/Alex/Documents/Mendeley Desktop/Soul{\'{e}} et al/A universal calculus for stream processing languages/Soul{\'{e}} et al. - 2010 - A universal calculus for stream processing languages.pdf:pdf},
  isbn = {3642119565},
  issn = {03029743},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  pages = {507--528},
  title = {{A universal calculus for stream processing languages}},
  volume = {6012 LNCS},
  year = {2010}
}
@techreport{Decker2015,
  author = {Decker, Norman},
  file = {:Users/Alex/Documents/Mendeley Desktop/Decker/Online Runtime Verification of Multicore Systems/Decker - 2015 - Online Runtime Verification of Multicore Systems.pdf:pdf},
  title = {{Online Runtime Verification of Multicore Systems}},
  url = {http://en.wikipedia.org/wiki/Runtime{\_}verification},
  year = {2015}
}
@article{Donze2012,
  author = {Donz{\'{e}}, a and Maler, O and Bartocci, E},
  file = {:Users/Alex/Documents/Mendeley Desktop/Donz{\'{e}}, Maler, Bartocci/On temporal logic and signal processing/Donz{\'{e}}, Maler, Bartocci - 2012 - On temporal logic and signal processing.pdf:pdf},
  journal = {{\ldots} for Verification and {\ldots}},
  title = {{On temporal logic and signal processing}},
  url = {http://link.springer.com/chapter/10.1007/978-3-642-33386-6{\_}9$\backslash$nhttp://www.mathworks.com/tagteam/43815{\_}9320v06{\_}Simulink7{\_}v7.pdf},
  year = {2012}
}
@article{Autosar2015,
  author = {Autosar},
  file = {:Users/Alex/Documents/Mendeley Desktop/Autosar/Specification of Timing Extensions/Autosar - 2015 - Specification of Timing Extensions.pdf:pdf},
  title = {{Specification of Timing Extensions}},
  year = {2015}
}
@incollection{Attard2016,
  author = {Attard, Duncan Paul and Francalanza, Adrian},
  booktitle = {Runtime Verification - 16th International Conference, Madrid},
  doi = {10.1007/978-3-319-46982-9_31},
  file = {:Users/Alex/Documents/Mendeley Desktop/Attard, Francalanza/A Monitoring Tool for a Branching-Time Logic/Attard, Francalanza - 2016 - A Monitoring Tool for a Branching-Time Logic.pdf:pdf},
  number = {163406},
  pages = {473--481},
  title = {{A Monitoring Tool for a Branching-Time Logic}},
  url = {http://link.springer.com/10.1007/978-3-319-46982-9{\_}31},
  year = {2016}
}
@incollection{Reger2016,
  author = {Reger, Giles and Hall{\'{e}}, Sylvain and Falcone, Yli{\`{e}}s},
  doi = {10.1007/978-3-319-46982-9_3},
  file = {:Users/Alex/Documents/Mendeley Desktop/Reger, Hall{\'{e}}, Falcone/Third International Competition on Runtime Verification/Reger, Hall{\'{e}}, Falcone - 2016 - Third International Competition on Runtime Verification.pdf:pdf},
  pages = {21--37},
  title = {{Third International Competition on Runtime Verification}},
  url = {http://link.springer.com/10.1007/978-3-319-46982-9{\_}3},
  year = {2016}
}
@article{Smith2008,
  abstract = {NASA spends millions designing and building spacecraft for its missions. The dependence on software is growing as spacecraft become more complex. With the increasing dependence on software comes the risk that bugs can lead to the loss of a mission. At NASApsilas Jet Propulsion Laboratory new tools are being developed to address this problem. Logic model checking and runtime verification can increase the confidence in a design or an implementation. A barrier to the application of such property-based checks is the difficulty in mastering the requirements notations that are currently available. For these techniques to be easily usable, a simple but expressive requirement specification method is essential. This paper describes a requirements capture notation and supporting tool that graphically captures formal requirements and converts them into automata that can be used in model checking and for runtime verification.},
  author = {Smith, Margaret H. and Havelund, Klaus},
  doi = {10.1109/RE.2008.50},
  file = {:Users/Alex/Documents/Mendeley Desktop/Smith, Havelund/Requirements capture with RCAT/Smith, Havelund - 2008 - Requirements capture with RCAT.pdf:pdf},
  isbn = {9780769533094},
  journal = {Proceedings of the 16th IEEE International Requirements Engineering Conference, RE'08},
  pages = {183--192},
  title = {{Requirements capture with RCAT}},
  year = {2008}
}
@article{Havelund2004,
  abstract = {We present an overview of the Java PathExplorer runtime verification tool, in short referred to as JPAX. JPAX can monitor the execution of a Java program and check that it conforms with a set of user provided properties formulated in temporal logic. JPAX can in addition analyze the program for concurrency errors such as deadlocks and data races. The concurrency analysis requires no user provided specification. The tool facilitates automated instrumentation of a program's bytecode, which when executed will emit an event stream, the execution trace, to an observer. The observer dispatches the incoming event stream to a set of observer processes, each performing a specialized analysis, such as the temporal logic verification, the deadlock analysis and the data race analysis. Temporal logic specifications can be formulated by the user in the Maude rewriting logic, where Maude is a high-speed rewriting system for equational logic, but here extended with executable temporal logic. The Maude rewriting engine is then activated as an event driven monitoring process. Alternatively, temporal specifications can be translated into automata or algorithms that can efficiently check the event stream. JPAX can be used during program testing to gain increased information about program executions, and can potentially furthermore be applied during operation to survey safety critical systems.},
  author = {Havelund, Klaus and Roşu, Grigore},
  doi = {10.1023/B:FORM.0000017721.39909.4b},
  file = {:Users/Alex/Documents/Mendeley Desktop/Havelund, Roşu/An Overview of the Runtime Verification Tool Java PathExplorer/Havelund, Roşu - 2004 - An Overview of the Runtime Verification Tool Java PathExplorer.pdf:pdf},
  isbn = {0925-9856},
  issn = {09259856},
  journal = {Formal Methods in System Design},
  keywords = {Automata,Data races,Deadlocks,Dynamic programming,Java,Maude,Program instrumentation,Rewriting logic,Runtime verification,Temporal logic,Trace analysis},
  number = {2},
  pages = {189--215},
  title = {{An Overview of the Runtime Verification Tool Java PathExplorer}},
  volume = {24},
  year = {2004}
}
@incollection{Leucker2007,
  abstract = {We present regular linear temporal logic (RLTL), a logic that generalizes linear temporal logic with the ability to use regular expressions arbitrarily as sub-expressions. Every LTL operator can be defined as a context in regular linear temporal logic. This implies that there is a (linear) translation from LTL to RLTL. Unlike LTL, regular linear temporal logic can define all $\omega$-regular languages, while still keeping the satisfiability problem in PSPACE. Unlike the extended temporal logics ETL*, RLTL is defined with an algebraic signature. In contrast to the linear time $\mu$-calculus, RLTL does not depend on fix-points in its syntax. {\textcopyright} Springer-Verlag Berlin Heidelberg 2007.},
  address = {Berlin, Heidelberg},
  author = {Leucker, Martin and S{\'{a}}nchez, C{\'{e}}sar},
  booktitle = {Theoretical Aspects of Computing – ICTAC 2007},
  doi = {10.1007/978-3-540-75292-9_20},
  file = {:Users/Alex/Documents/Mendeley Desktop/Leucker, S{\'{a}}nchez/Regular linear temporal logic/Leucker, S{\'{a}}nchez - 2007 - Regular linear temporal logic.pdf:pdf},
  isbn = {978-3-540-75292-9},
  keywords = {Algebraic signature,Computer programming languages,Linear programming,Linear temporal logic,Problem solving,Temporal logic,Translation (languages)},
  pages = {291--305},
  publisher = {Springer Berlin Heidelberg},
  title = {{Regular Linear Temporal Logic}},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049105804{\&}partnerID=40{\&}md5=5973fc0db06d3d353f48dc6841c9cf38 http://link.springer.com/10.1007/978-3-540-75292-9{\_}20},
  volume = {4711 LNCS},
  year = {2007}
}
@article{Kim1999,
  abstract = {We describe the Monitoring and Checking (MaC) framework which provides assurance on the correctness of program execution at run-time. Our approach complements the two traditional approaches for ensuring that a system is correct, namely static analysis and testing. Unlike these approaches, which try to ensure that all possible executions of the system are correct, our approach concentrates on the correctness of the current execution of the system. The MaC architecture consists of three components: a filter, an event recognizer, and a run-time checker. The filter extracts low-level information, e.g., values of program variables and function calls, from the system code, and sends it to the event recognizer. From this low-level information, the event recognizer detects the occurrence of "abstract requirements-level events, and informs the run-time checker about them. The run-time checker uses these events to check that the current system execution conforms to the formal requ...},
  author = {Kim, Moonjoo and Viswanathan, Mahesh},
  file = {:Users/Alex/Documents/Mendeley Desktop/Kim, Viswanathan/MaC A Framework for Run-time Correctness Assurance of Real-Time Systems/Kim, Viswanathan - 1999 - MaC A Framework for Run-time Correctness Assurance of Real-Time Systems.pdf:pdf},
  journal = {Database},
  number = {January},
  pages = {1--59},
  title = {{MaC : A Framework for Run-time Correctness Assurance of Real-Time Systems}},
  volume = {0505},
  year = {1999}
}
@article{Zheng2015,
  author = {Zheng, Xi and Julien, Christine and Podorozhny, Rodion and Cassez, Franck},
  doi = {10.1109/MASS.2015.15},
  file = {:Users/Alex/Documents/Mendeley Desktop/Zheng et al/BraceAssertion Runtime verification of cyber-physical systems/Zheng et al. - 2015 - BraceAssertion Runtime verification of cyber-physical systems.pdf:pdf},
  isbn = {9781467391009},
  journal = {Proceedings - 2015 IEEE 12th International Conference on Mobile Ad Hoc and Sensor Systems, MASS 2015},
  keywords = {Cyber Physical Systems,Formal Method,Runtime Verification},
  pages = {298--306},
  title = {{BraceAssertion: Runtime verification of cyber-physical systems}},
  year = {2015}
}
@article{Hewitt1973,
  abstract = {This paper proposes a modular ACTOR architecture and definitional method for artificial intelligence that is conceptually based on a single kind of object: actors [or, if you will , virtual processors, activation frames, or streams]. The formalism makes no presuppositions about the representation of primitive data structures and control structures. Such structures can be programmed, micro-coded, or hard wired 1n a uniform modular fashion. In fact it is impossible to determine whether a given object is "really" represented as a list , a vector, a hash table, a function, or a process. The architecture will efficiently run the coming generation of PLANNER-like artificia l intelligence languages including those requiring a high degree of parallelism. The efficiency is gained without loss of programming generality because it only makes certain actors more efficient; it does not change their behavioral characteristics. The architecture is general with respect to control structure and does not have or need goto, interrupt, or semaphore primitives. The formalism achieves the goals that the disallowed constructs are intended to achieve by other more structured methods.},
  author = {Hewitt, Carl and Bishop, Peter and Steiger, Richard},
  doi = {10.1145/359545.359563},
  file = {:Users/Alex/Documents/Mendeley Desktop/Hewitt, Bishop, Steiger/A Universal Modular ACTOR Formalism for Artificial Intelligence/Hewitt, Bishop, Steiger - 1973 - A Universal Modular ACTOR Formalism for Artificial Intelligence.pdf:pdf},
  isbn = {9781450336697},
  issn = {01635700},
  journal = {Ijcai},
  pages = {235--245},
  pmid = {862639},
  title = {{A Universal Modular ACTOR Formalism for Artificial Intelligence}},
  year = {1973}
}
@article{Autosar2015a,
  author = {Autosar},
  file = {:Users/Alex/Documents/Mendeley Desktop/Autosar/Timing Analysis/Autosar - 2015 - Timing Analysis.pdf:pdf},
  pages = {1--77},
  title = {{Timing Analysis}},
  url = {papers2://publication/uuid/C75492C8-9601-4EAD-A101-CBDE3C92EAEC},
  year = {2015}
}
@article{Chen2006,
  author = {Chen, Donghuo},
  file = {:Users/Alex/Documents/Mendeley Desktop/Chen/Symmetry in Event Structures ∗/Chen - 2006 - Symmetry in Event Structures ∗.pdf:pdf},
  isbn = {1595931082},
  keywords = {equivalences,event structures,symmetry},
  pages = {1850--1851},
  title = {{Symmetry in Event Structures ∗}},
  year = {2006}
}
@article{Chen2009,
  author = {Chen, Feng and Jin, Dongyun and Meredith, Patrick and Ro$\backslash$csu, Grigore},
  file = {:Users/Alex/Documents/Mendeley Desktop/Chen et al/Monitoring Oriented Programming - A Project Overview/Chen et al. - 2009 - Monitoring Oriented Programming - A Project Overview.pdf:pdf},
  journal = {Proceedings of the Fourth International Conference on Intelligent Computing and Information Systems (ICICIS'09)},
  pages = {----},
  title = {{Monitoring Oriented Programming - A Project Overview}},
  year = {2009}
}
@article{Soule2012,
  abstract = {At one level, this paper is about River, a virtual execution environment for stream processing. Stream processing is a paradigm well-suited for many modern data processing systems that ingest high-volume data streams from the real world, such as audio/video streaming, high-frequency trading, and security monitoring. One attractive property of stream processing is that it lends itself to parallelization on multicores, and even to distribution on clusters when extreme scale is required. Stream processing has been co-evolved by several communities, leading to diverse languages with similar core concepts. Providing a common execution environment reduces language development effort and increases portability. We designed River as a practical realization of Brooklet, a calculus for stream processing. So at another level, this paper is about a journey from theory (the calculus) to practice (the execution environment). The challenge is that, by definition, a calculus abstracts away all but the most central concepts. Hence, there are several research questions in concretizing the missing parts, not to mention a significant engineering effort in implementing them. But the effort is well worth it, because using a calculus as a foundation yields clear semantics and proven correctness results.},
  author = {Soul{\'{e}}, R and Hirzel, Martin and Gedik, B and Grimm, Robert},
  doi = {10.1145/2335484.2335487},
  file = {:Users/Alex/Documents/Mendeley Desktop/Soul{\'{e}} et al/From a calculus to an execution environment for stream processing/Soul{\'{e}} et al. - 2012 - From a calculus to an execution environment for stream processing.pdf:pdf},
  isbn = {9781450313155},
  journal = {Proceedings of the 6th ACM {\ldots}},
  keywords = {cql,domain specific language,inter-,mediate language,sawzall,stream processing,streamit},
  pages = {20--31},
  title = {{From a calculus to an execution environment for stream processing}},
  url = {http://dl.acm.org/citation.cfm?id=2335487},
  year = {2012}
}
@article{Blackburn2006,
  abstract = {Since benchmarks drive computer science research and industry product development, which ones we use and how we evaluate them are key questions for the community. Despite complex runtime tradeoffs due to dynamic compilation and garbage collection required for Java programs, many evaluations still use methodologies developed for C, C++, and Fortran. SPEC, the dominant purveyor of benchmarks, compounded this problem by institutionalizing these methodologies for their Java benchmark suite. This paper recommends benchmarking selection and evaluation methodologies, and introduces the DaCapo benchmarks, a set of open source, client-side Java benchmarks. We demonstrate that the complex interactions of (1) architecture, (2) compiler, (3) virtual machine, (4) memory management, and (5) application require more extensive evaluation than C, C++, and Fortran which stress (4) much less, and do not require (3). We use and introduce new value, time-series, and statistical metrics for static and dynamic properties such as code complexity, code size, heap composition, and pointer mutations. No benchmark suite is definitive, but these metrics show that DaCapo improves over SPEC Java in a variety of ways, including more complex code, richer object behaviors, and more demanding memory system requirements. This paper takes a step towards improving methodologies for choosing and evaluating benchmarks to foster innovation in system design and implementation for Java and other managed languages.},
  author = {Blackburn, Stephen M and Garner, Robin and Hoffmann, Chris and Khan, Asjad M and Mckinley, Kathryn S and Bentzur, Rotem and Diwan, Amer and Feinberg, Daniel and Frampton, Daniel and Guyer, Samuel Z and Hirzel, Martin and Hosking, Antony and Jump, Maria and Lee, Han and Moss, J Eliot B and Phansalkar, Aashish and Stefanovi, Darko},
  doi = {10.1145/1167515.1167488},
  isbn = {1595933484},
  issn = {03621340},
  journal = {Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
  keywords = {benchmark,dacapo,java,methodology,spec},
  pages = {169--190},
  title = {{The DaCapo Benchmarks : Java Benchmarking Development and Analysis}},
  url = {https://users.cecs.anu.edu.au/{~}steveb/pubs/papers/dacapo-oopsla-2006.pdf},
  year = {2006}
}
@incollection{Decker2013,
  author = {Decker, Normann and Leucker, Martin and Thoma, Daniel},
  doi = {10.1007/978-3-642-40787-1_11},
  file = {:Users/Alex/Documents/Mendeley Desktop/Decker, Leucker, Thoma/Impartiality and Anticipation for Monitoring of Visibly Context-Free Properties/Decker, Leucker, Thoma - 2013 - Impartiality and Anticipation for Monitoring of Visibly Context-Free Properties.pdf:pdf},
  pages = {183--200},
  title = {{Impartiality and Anticipation for Monitoring of Visibly Context-Free Properties}},
  url = {http://link.springer.com/10.1007/978-3-642-40787-1{\_}11},
  year = {2013}
}

