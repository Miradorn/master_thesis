% !TEX root = ../thesis.tex
%
\chapter{Related Work}
\label{sec:related}
\todo{Just a collection of thoughts for now, needs to be polished a lot}

% \cleanchapterquote{A picture is worth a thousand words. An interface is worth a thousand pictures.}{Ben Shneiderman}{(Professor for Computer Science)}
As Runtime Verification is a widely researched field there are many different approaches towards monitoring programs.
As stated in~\cite{Havelund2008} most approaches are geared towards Java, while many critical systems are written in C.
Because our implementation of a runtime is independent of the environment of the monitored program, this opens up the possibility to investigate this somewhat neglected field.
Therefore ways to generate traces from C programs are highlighted in this chapter.

TeSSLa itself and the implemented runtime builds on concepts and results of many other Runtime Verification techniques.
In the following sections some of them are highlighted to give a better understanding of choices made during this thesis.

\section{Distributed Verification Techniques}
\label{sec:related:distributed}

While most implementations of RV systems don't consider or use modern ways of parallelism and distribution and focus on programs running locally, in~\cite{Mostafa2015} a way to monitor distributed programs is given.
To do this distributed monitors, which have to communicate with one another, are implemented.

As stated earlier, the TeSSLa runtime doesn't care about the environment of the monitored program, so it doesn't distinguish between traces from distributed and non distributed programs.
But the runtime itself is highly concurrent and can be distributed easily to many processors or event different computers.
Therefore many of the definitions for distributed monitors can be used to reason about the behaviour of the Runtime.

\section{LOLA}
\label{sec:related:lola}

LOLA~\cite{DAngelo2005} has big influence on TeSSLa and the theoretical work of this thesis.
LOLA defines a very small core language to describe streams as the result of combinations on other streams.
In contrast to TeSSLa it is defined in regards of a discrete timing model.

Lola defines a notion of efficiently monitorable properties and an approach to monitor these properties.

TeSSLa takes concepts of LOLA and applies them to a continuous model of time and introduces a language and a rich
set of functions that can be applied to streams.

\section{Copilot}
\label{sec:related:copilot}

The realtime runtime monitor system Copilot was introduced in~\cite{Pike2010}.
Copilot is designed to overcome the shortcomings of existing RV tools in regards to hard-realtime software written in C.

To do so they first define characteristics a monitoring approach has to fullfill to be considered valuable for this domain.
The four principles are:

\begin{description}
  \item[Functionality] Monitors cannot change the functionality of the observed program unless a failure is observed.
  \item[Schedulability] Monitors cannot alter the schedule of the observed program.
  \item[Certifiability] Monitors must minimize the difficulty in re-validating the observed program; in particular, we make it our goal to avoid modifying the observed programs source code.
  \item[SWaP overhead] Monitors must minimize the additional overhead required including size, weight, and power (SWaP).
\end{description}

The monitors follow a sampling based approach, where at specified steps the values of global variables are observed and the monitors are evaluated
on that values.
While sampling based approaches are widely disregarded in RV, because they can lead to both false positives and false negatives,
they argue:

\begin{quote}
  In a hard real-time context, sampling is a suitable strategy. Under
  the assumption that the monitor and the observed program share a global clock and a static periodic schedule, while false positives are possible, false negatives are not.~\cite{Pike2010}
\end{quote}

A special detail of Copilot is that monitors aren't inlined into the program but can be scheduled as independet processes.
The implementation of the TeSSLa runtime in this thesis follows a similar approach: It is a totally independent program,
and therefore also has some of the gains in regard to the specified four characteristics.
Because the runtime works with all kinds of traces, it is insignificant how they are produced:
It can work with traces based on sampling, working in a similar fashion as Copilot, or by actually instrumenting code to generate
traces, which alters the semantics of the program.

% Another shortcoming of inlining monitors is that certified code (e.g., DO-178B for avionics [Inc92]) is common in this domain.
% Inlining monitors could necessitate re-certifying the observed program.

\section{RMoR}
\label{sec:related:rmor}

RMoR is another approach on monitoring C programs.
It does so by transforming C code into an \emph{armored} version, which includes monitors to check conformance to a specification.

Specifications are given as a textual representation of state machines.
The specifications are then interweaved into the programm using CIL~\cite{Necula2002}.
Specifications work on the level of function calls and state properties like \emph{write may never be called before open was called}.
Because Software Developers are often working at the same abstraction level (in contrast to e.g.\ assembler or machine instructions), they can define specifications without having to learn new concepts.
For the TeSSLa runtime support for traces at the same abstraction level (function calls, variable reads and writes) is present and used in most of the tests in Section~\ref{TODO}.

Because RMoR specifications are interweaved into the program, their observations can not only be reported but also used to recover the program or even to prevent errors by calling specified functions when some condition is encountered.
The TeSSLa runtime doesn't support this out of the box, as it's primary purpose is testing and offline monitoring, but in Section~\ref{TODO:Further_WORK} we will look at ways to support this.

% \section{Driver Trace}
% \label{sec:related:drivertrace}
\section{MaC}
% \section{RiTHM}
